http://www.cnblogs.com/c-cloud/p/3224788.html
KMP算法下，长为n的字符串中匹配长度为m的子串的复杂度为（）
正确答案: B   你的答案: D (错误)
O(N)
O(M+N)
O(N+LOGM)
O(M+LOGN)



请问在64位平台机器下sizeof(string_a),sizeof(string_b)大小分别是（） 
1.char *string_a=(char *)malloc(100*sizeof(char));
2.char string_b[100];
正确答案: A   你的答案: C (错误)

8 100
100 8
100 100
8 8
指针类型在64位下大小为8


char s[]="\\123456\123456\t";
printf("%d\n",strlen(s));

正确答案: A   你的答案: D (错误)

12
13
16
以上都不对

这里考查转义字符，注意 \\ 表示字符 \
\123表示字符 {
\t 表示制表符
这些都是一个字符。

串是一种特殊的线性表,其特殊性体现在()
正确答案: A   你的答案: C (错误)

数据元素是一个字符
可以顺序存储
数据元素可以是多个字符
可以链接存储


String str = new String(“abc”)，“abc”在内存中是怎么分配的？
正确答案: A C   你的答案: B (错误)

堆
栈
字符串常量区
寄存器
////////////////////////////////////////////////////////////////////////////////////////////
看了老半天才明白怎么计算的，可以看看这个解析。
先计算出next数组，然后要计算当前位置的nexteval，就将当前的字符与当前位置的next指向的字符比较，如果相等，那么这个nexteval就是前面那个的nexteval值，不等，那就是等于next值。
i              1 2 3 4 5 6 7 8 9
s             a b a b a a b a b
next        0 1 1 2 3 4 2 3 4
nexteval  0 1 0 1 0 4 1 0 1
第一个的nexteval为 0
第二个的next为1，但是位置1的是a, a!=b，所以nexteval[2] = next[2]。
第三个的next为1，位置1为a， a == a，所以nexteval[3] = nexteval[1]
第四个的next为2，位置2为b， b == b，所以nexteval[4] = nexteval[2]
依次类推就可以了
next数组下标从1开始计算
next[1] 肯定是 0 
next[2] 肯定是 1
next[n] 的情况，将前面n-1个字符，计算从首尾开始组成最大的相同子串的长度，如果找到，//那么next值是该长度加1，否则next值是1。//

举例
next[6]的计算，字符串第六位是 a ，( ababa a ababaa)
将前面的5个字符，从头尾开始取4个组成子串比较，如果不相等，则从首尾取3个字符组成子串继续比较，并以此类推， 如果一直比较到最后一个字符都不相等，那么该next值为1。
4个字符的情况：abab : baba
3个字符的情况：aba   :  aba  此时相等，那么next[6] = 3+1 = 4

