http://www.cnblogs.com/c-cloud/p/3224788.html
KMP算法下，长为n的字符串中匹配长度为m的子串的复杂度为（）
正确答案: B   你的答案: D (错误)
O(N)
O(M+N)
O(N+LOGM)
O(M+LOGN)



请问在64位平台机器下sizeof(string_a),sizeof(string_b)大小分别是（） 
1.char *string_a=(char *)malloc(100*sizeof(char));
2.char string_b[100];
正确答案: A   你的答案: C (错误)

8 100
100 8
100 100
8 8
指针类型在64位下大小为8


next数组下标从1开始计算
next[1] 肯定是 0 
next[2] 肯定是 1
next[n] 的情况，将前面n-1个字符，计算从首尾开始组成最大的相同子串的长度，如果找到，//那么next值是该长度加1，否则next值是1。//

举例
next[6]的计算，字符串第六位是 a ，( ababa a ababaa)
将前面的5个字符，从头尾开始取4个组成子串比较，如果不相等，则从首尾取3个字符组成子串继续比较，并以此类推， 如果一直比较到最后一个字符都不相等，那么该next值为1。
4个字符的情况：abab : baba
3个字符的情况：aba   :  aba  此时相等，那么next[6] = 3+1 = 4



char s[]="\\123456\123456\t";
printf("%d\n",strlen(s));

正确答案: A   你的答案: D (错误)

12
13
16
以上都不对

这里考查转义字符，注意 \\ 表示字符 \
\123表示字符 {
\t 表示制表符
这些都是一个字符。
